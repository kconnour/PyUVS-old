~~~~templates.py
class Template
    # setup fig with width and height

class TripleDouble(Template)
    # This is the current StandardApoapseMUVQuicklook

class StandardApoapseMUVQuicklook(TripleDouble)
    # the axes have more descriptive names

class Plain
class ExtendedApoapseMUVQuicklook

~~~~files.py
class L1bFile
    def __init__(self, path: str):
        self.hdul = fits.open(path)

    def beta_angle_flip() -> bool:

~~~~idk where to put this
# Create a generic data structure that can be manipulated. Its one job is to
# hold the relevant data (GENERICALLY) and colorize it. I think the generic
# part is important for the D in SOLID for future database additions
class FalseColorDetectorImage:
    self.primary: np.ndarray #defined in constructor
    self.alt = None
    self.mask = None
    self.rgb = None

    def add_alt(alt_array):
        self.alt = alt_array
        check alt is same shape as primary

    def create_alt_mask():
        return np.where(self.alt == 0)

    def heq():
        self.mask = create_alt_mask()  # also add SZA mask from 0--102
        self.rgb = scikit-image.heq(self.primary, mask=self.mask)

    def linear():
        # code

    def sharpen():
        # code

def standard_ql_coloring():
    # do the standard stuff


class SegmentDetectorImage
    def make_plot_grid():
        return X, Y

    def make_plot_fill():

    def plot_rgb_array():

    def plot_other_array():


# instead of having functions that handle every conceivable combination of
# templates, coloring choices, masks, etc. I should have them as methods of
# an object and function wrappers around common choices

# If the templates have *named* axes I can have methods like fill_data_axis()
class ApoapseMUVQuicklook:
    def __init__(self, template: Template):
        self.template = template

    def heq_data(ax, di: DetectorImage):
        di.heq()
        ax.plot(di.rgb)


# whether I have database or data files, I want to put several fields into 1 array (primary, alt, ...)
# FalseColorDetectorImage takes these and thus abstracts the data. It has all the methods to go from primary --> rgb
# add functions to call common groupings of methods



~~~~~DATA~~~~~~
From files
----------
* glob to get the abs paths
* open fits files
* determine beta angle flip of each file
* determine swath number of each file
* determine relay swath of each file
* determine dayside/nightside of each file
* store relevant data (primary, alt, sza, mirror angle)
* flatfield correct the primary

x colorize primary "stack"
* split stack into swath numbers

def remove_non_latest_filenames():
    ...

class L1bFile()
    def __init__(self, path: str):
        self.hdul = fits.open(path)

    def get_latitude():
        return latitude array

    def get_longitude():
        return longitude array

    def beta_angle_flip():
        return True or False

    def relay_swath():
        ...

    def dayside():
        ...


class SegementIntegrationStack:
    def __init__(self, data_stack, swath_number_stack):
        self.


PYUVS
files.py - find all files on computer + only most recent + delete old
data.py - transform hdul into class

